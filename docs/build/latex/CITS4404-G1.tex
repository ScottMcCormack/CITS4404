%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{CITS4404-G1 Documentation}
\date{Nov 03, 2017}
\release{1.0}
\author{Scott McCormack}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{eLCS package}
\label{\detokenize{eLCS::doc}}\label{\detokenize{eLCS:welcome-to-cits4404-g1-s-documentation}}\label{\detokenize{eLCS:elcs-package}}

\section{Submodules}
\label{\detokenize{eLCS:submodules}}

\section{eLCS.Algorithm module}
\label{\detokenize{eLCS:module-eLCS.Algorithm}}\label{\detokenize{eLCS:elcs-algorithm-module}}\index{eLCS.Algorithm (module)}\index{Algorithm (class in eLCS.Algorithm)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Algorithm.Algorithm}}\pysigline{\sphinxbfcode{class }\sphinxcode{eLCS.Algorithm.}\sphinxbfcode{Algorithm}}
Bases: \sphinxcode{object}

The major controlling module of eLCS.

Includes the major run loop which controls learning over a specified number of iterations.
Also includes periodic tracking of estimated performance, and checkpoints where complete
evaluations of the eLCS rule population is performed.

Two options are available for the initialisation of the algorithm
1.  Do a Population reboot using an existing saved rule population, or
2.  Build the Population from scratch from given data
\index{doContPopEvaluation() (eLCS.Algorithm.Algorithm method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Algorithm.Algorithm.doContPopEvaluation}}\pysiglinewithargsret{\sphinxbfcode{doContPopEvaluation}}{\emph{isTrain}}{}
Performs evaluation of population via the copied environment.

Specifically developed for continuous phenotype evaulation. The population is maintained unchanging
throughout the evaluation.  Works on both training and testing data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{isTrain} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{doPopEvaluation() (eLCS.Algorithm.Algorithm method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Algorithm.Algorithm.doPopEvaluation}}\pysiglinewithargsret{\sphinxbfcode{doPopEvaluation}}{\emph{isTrain}}{}
Performs a complete evaluation of the current rule population.

The population is unchanged throughout this evaluation. Works on both training and testing data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{isTrain} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{getRuntimeParams() (eLCS.Algorithm.Algorithm method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Algorithm.Algorithm.getRuntimeParams}}\pysiglinewithargsret{\sphinxbfcode{getRuntimeParams}}{}{}
\end{fulllineitems}

\index{plotResult() (eLCS.Algorithm.Algorithm method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Algorithm.Algorithm.plotResult}}\pysiglinewithargsret{\sphinxbfcode{plotResult}}{}{}
Plot the runtime params from the execution of the LCS

\end{fulllineitems}

\index{populationReboot() (eLCS.Algorithm.Algorithm method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Algorithm.Algorithm.populationReboot}}\pysiglinewithargsret{\sphinxbfcode{populationReboot}}{}{}
Manages the reformation of a previously saved eLCS classifier population

\end{fulllineitems}

\index{runIteration() (eLCS.Algorithm.Algorithm method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Algorithm.Algorithm.runIteration}}\pysiglinewithargsret{\sphinxbfcode{runIteration}}{\emph{state\_phenotype}, \emph{exploreIter}}{}
Run a single eLCS learning iteration.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{state\_phenotype} (\sphinxstyleliteralemphasis{list}) \textendash{} Listing consisting of the training state and training phenotype

\item {} 
\sphinxstyleliteralstrong{exploreIter} (\sphinxstyleliteralemphasis{int}) \textendash{} The current iteration

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{run\_eLCS() (eLCS.Algorithm.Algorithm method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Algorithm.Algorithm.run_eLCS}}\pysiglinewithargsret{\sphinxbfcode{run\_eLCS}}{}{}
Runs eLCS algorithm, runs by default after the class has been initialised

\end{fulllineitems}


\end{fulllineitems}



\section{eLCS.ClassAccuracy module}
\label{\detokenize{eLCS:module-eLCS.ClassAccuracy}}\label{\detokenize{eLCS:elcs-classaccuracy-module}}\index{eLCS.ClassAccuracy (module)}\index{ClassAccuracy (class in eLCS.ClassAccuracy)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassAccuracy.ClassAccuracy}}\pysigline{\sphinxbfcode{class }\sphinxcode{eLCS.ClassAccuracy.}\sphinxbfcode{ClassAccuracy}}
Bases: \sphinxcode{object}

Manages the logistical aspects of balance accuracy calculations.

These can handle unbalanced datasets, and/or datasets with multiple discrete classes.
\index{reportClassAccuracy() (eLCS.ClassAccuracy.ClassAccuracy method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassAccuracy.ClassAccuracy.reportClassAccuracy}}\pysiglinewithargsret{\sphinxbfcode{reportClassAccuracy}}{}{}
Print to standard out, summary on the class accuracy

\end{fulllineitems}

\index{updateAccuracy() (eLCS.ClassAccuracy.ClassAccuracy method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassAccuracy.ClassAccuracy.updateAccuracy}}\pysiglinewithargsret{\sphinxbfcode{updateAccuracy}}{\emph{thisIsMe}, \emph{accurateClass}}{}
Increment the appropriate cell of the confusion matrix
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{thisIsMe} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{accurateClass} \textendash{} 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{eLCS.Classifier module}
\label{\detokenize{eLCS:module-eLCS.Classifier}}\label{\detokenize{eLCS:elcs-classifier-module}}\index{eLCS.Classifier (module)}\index{Classifier (class in eLCS.Classifier)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{eLCS.Classifier.}\sphinxbfcode{Classifier}}{\emph{a=None}, \emph{b=None}, \emph{c=None}, \emph{d=None}}{}
Bases: \sphinxcode{object}

This module defines an individual classifier within the rule population, along with all respective parameters.

Also included are classifier-level methods, including constructors(covering, copy, reboot)
matching, subsumption, crossover, and mutation.  Parameter update methods are also included
\index{Mutation() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.Mutation}}\pysiglinewithargsret{\sphinxbfcode{Mutation}}{\emph{state}, \emph{phenotype}}{}
Mutates the condition of the classifier. Also handles phenotype mutation. This is a niche mutation, which means that the resulting classifier will still match the current instance.

\end{fulllineitems}

\index{buildMatch() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.buildMatch}}\pysiglinewithargsret{\sphinxbfcode{buildMatch}}{\emph{attRef}, \emph{state}}{}
Builds a matching condition for the classifierCovering method.

\end{fulllineitems}

\index{classifierCopy() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.classifierCopy}}\pysiglinewithargsret{\sphinxbfcode{classifierCopy}}{\emph{clOld}, \emph{exploreIter}}{}
Constructs an identical Classifier.  However, the experience of the copy is set to 0 and the numerosity 
is set to 1 since this is indeed a new individual in a population. Used by the genetic algorithm to generate 
offspring based on parent classifiers.

\end{fulllineitems}

\index{classifierCovering() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.classifierCovering}}\pysiglinewithargsret{\sphinxbfcode{classifierCovering}}{\emph{setSize}, \emph{exploreIter}, \emph{state}, \emph{phenotype}}{}
Makes a new classifier when the covering mechanism is triggered.

The new classifier will match the current training instance.
Covering will NOT produce a default rule (i.e. a rule with a completely general condition).

The classifier constructs phenotypes for:
1.  Discrete Phenotypes
2.  Continous Phenotypes
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{setSize} (\sphinxstyleliteralemphasis{int}) \textendash{} The set numerosity sum

\item {} 
\sphinxstyleliteralstrong{exploreIter} (\sphinxstyleliteralemphasis{int}) \textendash{} The current iteration

\item {} 
\sphinxstyleliteralstrong{state} (\sphinxstyleliteralemphasis{list}) \textendash{} The state

\item {} 
\sphinxstyleliteralstrong{phenotype} (\sphinxstyleliteralemphasis{int}) \textendash{} The state’s phenotype

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{continuousPhenotypeMutation() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.continuousPhenotypeMutation}}\pysiglinewithargsret{\sphinxbfcode{continuousPhenotypeMutation}}{\emph{phenotype}}{}
Mutate this rule’s continuous phenotype.

\end{fulllineitems}

\index{discretePhenotypeMutation() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.discretePhenotypeMutation}}\pysiglinewithargsret{\sphinxbfcode{discretePhenotypeMutation}}{}{}
Mutate this rule’s discrete phenotype.

\end{fulllineitems}

\index{equals() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.equals}}\pysiglinewithargsret{\sphinxbfcode{equals}}{\emph{cl}}{}
Returns if the two classifiers are identical in condition and phenotype. This works for discrete or continuous attributes or phenotypes.

\end{fulllineitems}

\index{getDelProp() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.getDelProp}}\pysiglinewithargsret{\sphinxbfcode{getDelProp}}{\emph{meanFitness}}{}
Returns the vote for deletion of the classifier.

\end{fulllineitems}

\index{isMoreGeneral() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.isMoreGeneral}}\pysiglinewithargsret{\sphinxbfcode{isMoreGeneral}}{\emph{cl}}{}
Returns if the classifier (self) is more general than cl. Check that all attributes specified in self are also specified in cl.

\end{fulllineitems}

\index{isSubsumer() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.isSubsumer}}\pysiglinewithargsret{\sphinxbfcode{isSubsumer}}{}{}
Returns if the classifier (self) is a possible subsumer. A classifier must be as or more accurate than the classifier it is trying to subsume.

\end{fulllineitems}

\index{match() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.match}}\pysiglinewithargsret{\sphinxbfcode{match}}{\emph{state}}{}
Returns if the classifier matches in the current situation.

\end{fulllineitems}

\index{phenotypeCrossover() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.phenotypeCrossover}}\pysiglinewithargsret{\sphinxbfcode{phenotypeCrossover}}{\emph{cl}}{}
Crossover a continuous phenotype

\end{fulllineitems}

\index{printClassifier() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.printClassifier}}\pysiglinewithargsret{\sphinxbfcode{printClassifier}}{}{}
Formats and returns an output string describing this classifier.

\end{fulllineitems}

\index{rebootClassifier() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.rebootClassifier}}\pysiglinewithargsret{\sphinxbfcode{rebootClassifier}}{\emph{classifierList}}{}
Rebuilds a saved classifier as part of the population Reboot

\end{fulllineitems}

\index{setAccuracy() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.setAccuracy}}\pysiglinewithargsret{\sphinxbfcode{setAccuracy}}{\emph{acc}}{}
Sets the accuracy of the classifier

\end{fulllineitems}

\index{setFitness() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.setFitness}}\pysiglinewithargsret{\sphinxbfcode{setFitness}}{\emph{fit}}{}
Sets the fitness of the classifier.

\end{fulllineitems}

\index{subsumes() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.subsumes}}\pysiglinewithargsret{\sphinxbfcode{subsumes}}{\emph{cl}}{}
Returns if the classifier (self) subsumes cl

\end{fulllineitems}

\index{uniformCrossover() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.uniformCrossover}}\pysiglinewithargsret{\sphinxbfcode{uniformCrossover}}{\emph{cl}}{}
Applies uniform crossover and returns if the classifiers changed. Handles both discrete and continuous attributes.  
\#SWARTZ: self. is where for the better attributes are more likely to be specified
\#DEVITO: cl. is where less useful attribute are more likely to be specified

\end{fulllineitems}

\index{updateAccuracy() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.updateAccuracy}}\pysiglinewithargsret{\sphinxbfcode{updateAccuracy}}{}{}
Update the accuracy tracker

\end{fulllineitems}

\index{updateCorrect() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.updateCorrect}}\pysiglinewithargsret{\sphinxbfcode{updateCorrect}}{}{}
Increases the correct phenotype tracking by one. Once an epoch has completed, rule accuracy can’t change.

\end{fulllineitems}

\index{updateExperience() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.updateExperience}}\pysiglinewithargsret{\sphinxbfcode{updateExperience}}{}{}
Increases the experience of the classifier by one. Once an epoch has completed, rule accuracy can’t change.

\end{fulllineitems}

\index{updateFitness() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.updateFitness}}\pysiglinewithargsret{\sphinxbfcode{updateFitness}}{}{}
Update the fitness parameter.

\end{fulllineitems}

\index{updateMatchSetSize() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.updateMatchSetSize}}\pysiglinewithargsret{\sphinxbfcode{updateMatchSetSize}}{\emph{matchSetSize}}{}
Updates the average match set size.

\end{fulllineitems}

\index{updateNumerosity() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.updateNumerosity}}\pysiglinewithargsret{\sphinxbfcode{updateNumerosity}}{\emph{num}}{}
Updates the numberosity of the classifier.  Notice that ‘num’ can be negative!

\end{fulllineitems}

\index{updateTimeStamp() (eLCS.Classifier.Classifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Classifier.Classifier.updateTimeStamp}}\pysiglinewithargsret{\sphinxbfcode{updateTimeStamp}}{\emph{ts}}{}
Sets the time stamp of the classifier.

\end{fulllineitems}


\end{fulllineitems}



\section{eLCS.ClassifierSet module}
\label{\detokenize{eLCS:module-eLCS.ClassifierSet}}\label{\detokenize{eLCS:elcs-classifierset-module}}\index{eLCS.ClassifierSet (module)}\index{ClassifierSet (class in eLCS.ClassifierSet)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{eLCS.ClassifierSet.}\sphinxbfcode{ClassifierSet}}{\emph{pop\_reboot\_path=None}}{}
Bases: \sphinxcode{object}

This module handles all the classifier sets

This includes the population, match set and correct sets along with mechanisms and
heuristics that act on these sets.

This class can be initialized with the:
1.  Creation of a new population, or
2.  Reboots the population (i.e. read in from a previously saved population)
\index{addClassifierToPopulation() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.addClassifierToPopulation}}\pysiglinewithargsret{\sphinxbfcode{addClassifierToPopulation}}{\emph{cl}, \emph{covering}}{}
Adds a classifier to the set and increases the microPopSize value accordingly.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{cl} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{covering} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{clearSets() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.clearSets}}\pysiglinewithargsret{\sphinxbfcode{clearSets}}{}{}
Clears out references in the match and correct sets for the next learning iteration.

\end{fulllineitems}

\index{deleteFromCorrectSet() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.deleteFromCorrectSet}}\pysiglinewithargsret{\sphinxbfcode{deleteFromCorrectSet}}{\emph{deleteRef}}{}
Delete reference to classifier in population, contained in self.corectSet.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{deleteRef} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{deleteFromMatchSet() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.deleteFromMatchSet}}\pysiglinewithargsret{\sphinxbfcode{deleteFromMatchSet}}{\emph{deleteRef}}{}
Delete reference to classifier in population, contained in self.matchSet.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{deleteRef} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{deleteFromPopulation() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.deleteFromPopulation}}\pysiglinewithargsret{\sphinxbfcode{deleteFromPopulation}}{}{}
Deletes one classifier in the population.

The classifier that will be deleted is chosen by roulette wheel selection considering the deletion vote.
Returns the macro-classifier which got decreased by one micro-classifier.

\end{fulllineitems}

\index{deletion() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.deletion}}\pysiglinewithargsret{\sphinxbfcode{deletion}}{\emph{exploreIter}}{}
Returns the population size back to the maximum set by the user by deleting rules.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{exploreIter} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{doCorrectSetSubsumption() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.doCorrectSetSubsumption}}\pysiglinewithargsret{\sphinxbfcode{doCorrectSetSubsumption}}{}{}
Executes correct set subsumption.

The correct set subsumption looks for the most general subsumer classifier in the correct set
and subsumes all classifiers that are more specific than the selected one.

\end{fulllineitems}

\index{getFitnessSum() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.getFitnessSum}}\pysiglinewithargsret{\sphinxbfcode{getFitnessSum}}{\emph{setList}}{}
Returns the sum of the fitnesses of all classifiers in the set.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{setList} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{getIdenticalClassifier() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.getIdenticalClassifier}}\pysiglinewithargsret{\sphinxbfcode{getIdenticalClassifier}}{\emph{newCl}}{}
Looks for an identical classifier in the population.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{newCl} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{getIterStampAverage() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.getIterStampAverage}}\pysiglinewithargsret{\sphinxbfcode{getIterStampAverage}}{}{}
Returns the average of the time stamps in the correct set.

\end{fulllineitems}

\index{getPopFitnessSum() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.getPopFitnessSum}}\pysiglinewithargsret{\sphinxbfcode{getPopFitnessSum}}{}{}
Returns the sum of the fitnesses of all classifiers in the set.

\end{fulllineitems}

\index{getPopTrack() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.getPopTrack}}\pysiglinewithargsret{\sphinxbfcode{getPopTrack}}{\emph{accuracy}, \emph{exploreIter}, \emph{trackingFrequency}}{}
Returns a formatted output string to be printed to the Learn Track output file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{accuracy} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{exploreIter} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{trackingFrequency} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{insertDiscoveredClassifiers() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.insertDiscoveredClassifiers}}\pysiglinewithargsret{\sphinxbfcode{insertDiscoveredClassifiers}}{\emph{cl1}, \emph{cl2}, \emph{clP1}, \emph{clP2}, \emph{exploreIter}}{}
Inserts both discovered classifiers and activates GA subsumption if turned on.

Also checks for default rule (i.e. rule with completely general condition)
and prevents such rules from being added to the population, as it offers no predictive value within eLCS.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{cl1} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{cl2} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{clP1} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{clP2} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{exploreIter} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{makeCorrectSet() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.makeCorrectSet}}\pysiglinewithargsret{\sphinxbfcode{makeCorrectSet}}{\emph{phenotype}}{}
Constructs a correct set out of the given match set
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{phenotype} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{makeEvalMatchSet() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.makeEvalMatchSet}}\pysiglinewithargsret{\sphinxbfcode{makeEvalMatchSet}}{\emph{state}}{}
Constructs a match set for evaluation purposes which does not activate either covering or deletion.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{state} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{makeMatchSet() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.makeMatchSet}}\pysiglinewithargsret{\sphinxbfcode{makeMatchSet}}{\emph{state\_phenotype}, \emph{exploreIter}}{}
Constructs a match set from the population

Covering is initiated if the match set is empty or a rule with the current correct phenotype is absent.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{state\_phenotype} (\sphinxstyleliteralemphasis{list}) \textendash{} Listing consisting of the training state and training phenotype

\item {} 
\sphinxstyleliteralstrong{exploreIter} (\sphinxstyleliteralemphasis{int}) \textendash{} The current iteration

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{makePop() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.makePop}}\pysiglinewithargsret{\sphinxbfcode{makePop}}{}{}
Initializes the rule population, as an empty list

\end{fulllineitems}

\index{rebootPop() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.rebootPop}}\pysiglinewithargsret{\sphinxbfcode{rebootPop}}{\emph{pop\_reboot\_path}}{}
Remakes a previously evolved population from a saved text file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{pop\_reboot\_path} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{removeMacroClassifier() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.removeMacroClassifier}}\pysiglinewithargsret{\sphinxbfcode{removeMacroClassifier}}{\emph{ref}}{}
Removes the specified (macro-) classifier from the population.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{ref} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{runAttGeneralitySum() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.runAttGeneralitySum}}\pysiglinewithargsret{\sphinxbfcode{runAttGeneralitySum}}{\emph{isEvaluationSummary}}{}
Determine the population-wide frequency of attribute specification, and accuracy weighted specification.

Used in complete rule population evaluations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{isEvaluationSummary} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{runGA() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.runGA}}\pysiglinewithargsret{\sphinxbfcode{runGA}}{\emph{exploreIter}, \emph{state}, \emph{phenotype}}{}
The genetic discovery mechanism in eLCS is controlled here.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{exploreIter} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{state} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{phenotype} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{runPopAveEval() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.runPopAveEval}}\pysiglinewithargsret{\sphinxbfcode{runPopAveEval}}{\emph{exploreIter}}{}
Calculates some summary evaluations across the rule population including average generality.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{exploreIter} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{selectClassifierRW() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.selectClassifierRW}}\pysiglinewithargsret{\sphinxbfcode{selectClassifierRW}}{}{}
Selects parents using roulette wheel selection according to the fitness of the classifiers.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{selectClassifierT() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.selectClassifierT}}\pysiglinewithargsret{\sphinxbfcode{selectClassifierT}}{}{}
Selects parents using tournament selection according to the fitness of the classifiers.

\end{fulllineitems}

\index{setIterStamps() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.setIterStamps}}\pysiglinewithargsret{\sphinxbfcode{setIterStamps}}{\emph{exploreIter}}{}
Sets the time stamp of all classifiers in the set to the current time.

The current time is the number of exploration steps executed so far.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{exploreIter} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{subsumeClassifier() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.subsumeClassifier}}\pysiglinewithargsret{\sphinxbfcode{subsumeClassifier}}{\emph{cl=None}, \emph{cl1P=None}, \emph{cl2P=None}}{}
Tries to subsume a classifier in the parents.

If no subsumption is possible it tries to subsume it in the current set.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{cl} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{cl1P} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{cl2P} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{subsumeClassifier2() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.subsumeClassifier2}}\pysiglinewithargsret{\sphinxbfcode{subsumeClassifier2}}{\emph{cl}}{}
Tries to subsume a classifier in the correct set.

If no subsumption is possible the classifier is simply added to the population considering the
possibility that there exists an identical classifier.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{cl} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{updateSets() (eLCS.ClassifierSet.ClassifierSet method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.ClassifierSet.ClassifierSet.updateSets}}\pysiglinewithargsret{\sphinxbfcode{updateSets}}{\emph{exploreIter}}{}
Updates all relevant parameters in the current match and correct sets.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{exploreIter} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{eLCS.Constants module}
\label{\detokenize{eLCS:elcs-constants-module}}\label{\detokenize{eLCS:module-eLCS.Constants}}\index{eLCS.Constants (module)}\index{Constants (class in eLCS.Constants)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Constants.Constants}}\pysigline{\sphinxbfcode{class }\sphinxcode{eLCS.Constants.}\sphinxbfcode{Constants}}
Bases: \sphinxcode{object}

Stores and manages all algorithm run parameters

Parameters are accessible anywhere in the rest of the algorithm code by importing \sphinxtitleref{cons}
\index{loadParameters() (eLCS.Constants.Constants method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Constants.Constants.loadParameters}}\pysiglinewithargsret{\sphinxbfcode{loadParameters}}{\emph{config\_file}}{}
Load the environment parameters from yaml configuration file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{config\_file} (\sphinxstyleliteralemphasis{str}) \textendash{} Path to the configuration yaml file

\item[{Returns}] \leavevmode
Parameters read from yaml file

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{parseIterations() (eLCS.Constants.Constants method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Constants.Constants.parseIterations}}\pysiglinewithargsret{\sphinxbfcode{parseIterations}}{}{}
Parse the ‘learningIterations’ string

Identify the maximum number of learning iterations as well as evaluation checkpoints

\end{fulllineitems}

\index{referenceEnv() (eLCS.Constants.Constants method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Constants.Constants.referenceEnv}}\pysiglinewithargsret{\sphinxbfcode{referenceEnv}}{\emph{env}}{}
Store reference to \sphinxtitleref{OfflineEnvironment} object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{env} (\sphinxstyleliteralemphasis{Environment}) \textendash{} An \sphinxtitleref{OfflineEnvironment} file

\end{description}\end{quote}

\end{fulllineitems}

\index{referenceTimer() (eLCS.Constants.Constants method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Constants.Constants.referenceTimer}}\pysiglinewithargsret{\sphinxbfcode{referenceTimer}}{\emph{timer}}{}
Store reference to the Timer object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{timer} \textendash{} A timer object

\end{description}\end{quote}

\end{fulllineitems}

\index{setConstants() (eLCS.Constants.Constants method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Constants.Constants.setConstants}}\pysiglinewithargsret{\sphinxbfcode{setConstants}}{\emph{config\_file}, \emph{dataset\_path}}{}
Parse the configuration file and save them as global constants
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{config\_file} (\sphinxstyleliteralemphasis{str}) \textendash{} Path to the configuration yaml file

\item {} 
\sphinxstyleliteralstrong{dataset\_path} (\sphinxstyleliteralemphasis{str}) \textendash{} Directory to the datasets

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{eLCS.DataManagement module}
\label{\detokenize{eLCS:module-eLCS.DataManagement}}\label{\detokenize{eLCS:elcs-datamanagement-module}}\index{eLCS.DataManagement (module)}\index{DataManagement (class in eLCS.DataManagement)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.DataManagement.DataManagement}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{eLCS.DataManagement.}\sphinxbfcode{DataManagement}}{\emph{trainFile}, \emph{testFile}, \emph{infoList=None}}{}
Bases: \sphinxcode{object}

Able to manage both training and testing data.

This module loads the dataset, detects and characterizes all attributes in the dataset,
handles missing data, and finally formats the data so that it may be conveniently utilized by eLCS.
\index{characterizeAttributes() (eLCS.DataManagement.DataManagement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.DataManagement.DataManagement.characterizeAttributes}}\pysiglinewithargsret{\sphinxbfcode{characterizeAttributes}}{\emph{rawData}}{}
Determine range (if continuous) or states (if discrete) for each attribute and saves this information
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{rawData} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{characterizeDataset() (eLCS.DataManagement.DataManagement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.DataManagement.DataManagement.characterizeDataset}}\pysiglinewithargsret{\sphinxbfcode{characterizeDataset}}{\emph{rawTrainData}}{}
Detect basic dataset parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{rawTrainData} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{characterizePhenotype() (eLCS.DataManagement.DataManagement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.DataManagement.DataManagement.characterizePhenotype}}\pysiglinewithargsret{\sphinxbfcode{characterizePhenotype}}{\emph{rawData}}{}
Determine range of phenotype values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{rawData} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{compareDataset() (eLCS.DataManagement.DataManagement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.DataManagement.DataManagement.compareDataset}}\pysiglinewithargsret{\sphinxbfcode{compareDataset}}{\emph{rawTestData}}{}
Ensures that the attributes in the testing data match those in the training data.

Also stores some information about the testing data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{rawTestData} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{discriminateAttributes() (eLCS.DataManagement.DataManagement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.DataManagement.DataManagement.discriminateAttributes}}\pysiglinewithargsret{\sphinxbfcode{discriminateAttributes}}{\emph{rawData}}{}
Determine whether attributes in dataset are discrete or continuous and saves this information.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{rawData} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{discriminateClasses() (eLCS.DataManagement.DataManagement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.DataManagement.DataManagement.discriminateClasses}}\pysiglinewithargsret{\sphinxbfcode{discriminateClasses}}{\emph{rawData}}{}
Determines number of classes and their identifiers.

Only used if phenotype is discrete.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{rawData} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{discriminatePhenotype() (eLCS.DataManagement.DataManagement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.DataManagement.DataManagement.discriminatePhenotype}}\pysiglinewithargsret{\sphinxbfcode{discriminatePhenotype}}{\emph{rawData}}{}
Determine whether the phenotype is Discrete(class-based) or Continuous
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{rawData} (\sphinxstyleliteralemphasis{list}) \textendash{} The raw data file loaded from

\end{description}\end{quote}

\end{fulllineitems}

\index{formatData() (eLCS.DataManagement.DataManagement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.DataManagement.DataManagement.formatData}}\pysiglinewithargsret{\sphinxbfcode{formatData}}{\emph{rawData}}{}
Get the data into a format convenient for the algorithm to interact with.

Specifically each instance is stored in a list as follows; {[}Attribute States, Phenotype, InstanceID{]}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{rawData} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{loadData() (eLCS.DataManagement.DataManagement method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.DataManagement.DataManagement.loadData}}\pysiglinewithargsret{\sphinxbfcode{loadData}}{\emph{dataFile}, \emph{doTrain}}{}
Load the data file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{dataFile} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{doTrain} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{eLCS.OfflineEnvironment module}
\label{\detokenize{eLCS:elcs-offlineenvironment-module}}\label{\detokenize{eLCS:module-eLCS.OfflineEnvironment}}\index{eLCS.OfflineEnvironment (module)}\index{OfflineEnvironment (class in eLCS.OfflineEnvironment)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.OfflineEnvironment.OfflineEnvironment}}\pysigline{\sphinxbfcode{class }\sphinxcode{eLCS.OfflineEnvironment.}\sphinxbfcode{OfflineEnvironment}}
Bases: \sphinxcode{object}

In the context of data mining and classification tasks,
the environment is a data set with a limited number of instances with X attributes
and some endpoint (typically a discrete phenotype or class) of interest.

This module loads the data set, automatically detects features of the data by executing
the DataManagement module
\index{getTestInstance() (eLCS.OfflineEnvironment.OfflineEnvironment method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.OfflineEnvironment.OfflineEnvironment.getTestInstance}}\pysiglinewithargsret{\sphinxbfcode{getTestInstance}}{}{}
Returns the current training instance.

\end{fulllineitems}

\index{getTrainInstance() (eLCS.OfflineEnvironment.OfflineEnvironment method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.OfflineEnvironment.OfflineEnvironment.getTrainInstance}}\pysiglinewithargsret{\sphinxbfcode{getTrainInstance}}{}{}
Returns the current training instance

\end{fulllineitems}

\index{newInstance() (eLCS.OfflineEnvironment.OfflineEnvironment method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.OfflineEnvironment.OfflineEnvironment.newInstance}}\pysiglinewithargsret{\sphinxbfcode{newInstance}}{\emph{isTraining}}{}
Shifts the environment to the next instance in the data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{isTraining} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{resetDataRef() (eLCS.OfflineEnvironment.OfflineEnvironment method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.OfflineEnvironment.OfflineEnvironment.resetDataRef}}\pysiglinewithargsret{\sphinxbfcode{resetDataRef}}{\emph{isTraining}}{}
Resets the environment back to the first instance in the current data set.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{isTraining} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{startEvaluationMode() (eLCS.OfflineEnvironment.OfflineEnvironment method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.OfflineEnvironment.OfflineEnvironment.startEvaluationMode}}\pysiglinewithargsret{\sphinxbfcode{startEvaluationMode}}{}{}
Turns on evaluation mode.  Saves the instance we left off in the training data.

\end{fulllineitems}

\index{stopEvaluationMode() (eLCS.OfflineEnvironment.OfflineEnvironment method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.OfflineEnvironment.OfflineEnvironment.stopEvaluationMode}}\pysiglinewithargsret{\sphinxbfcode{stopEvaluationMode}}{}{}
Turns off evaluation mode.  Re-establishes place in dataset.

\end{fulllineitems}


\end{fulllineitems}



\section{eLCS.OutputFileManager module}
\label{\detokenize{eLCS:elcs-outputfilemanager-module}}\label{\detokenize{eLCS:module-eLCS.OutputFileManager}}\index{eLCS.OutputFileManager (module)}\index{OutputFileManager (class in eLCS.OutputFileManager)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.OutputFileManager.OutputFileManager}}\pysigline{\sphinxbfcode{class }\sphinxcode{eLCS.OutputFileManager.}\sphinxbfcode{OutputFileManager}}
Bases: \sphinxcode{object}

This module contains the methods for generating the different output files generated by eLCS.

These files are generated at each learning checkpoint, and the last iteration.  These include…
* writePopStats: Summary of the population statistics
* writePop: Outputs a snapshot of the entire rule population including classifier conditions, classes, and parameters.
\index{writePop() (eLCS.OutputFileManager.OutputFileManager method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.OutputFileManager.OutputFileManager.writePop}}\pysiglinewithargsret{\sphinxbfcode{writePop}}{\emph{outFile}, \emph{exploreIter}, \emph{pop}}{}
Writes a tab delimited text file outputting the entire evolved rule population, including conditions,
phenotypes, and all rule parameters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{outFile} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{exploreIter} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{pop} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{writePopStats() (eLCS.OutputFileManager.OutputFileManager method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.OutputFileManager.OutputFileManager.writePopStats}}\pysiglinewithargsret{\sphinxbfcode{writePopStats}}{\emph{outFile}, \emph{trainEval}, \emph{testEval}, \emph{exploreIter}, \emph{pop}, \emph{correct}}{}
Makes output text file which includes all of the evaluation statistics for a complete analysis
of all training and testing data on the current eLCS rule population.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{outFile} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{trainEval} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{testEval} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{exploreIter} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{pop} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{correct} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{eLCS.Prediction module}
\label{\detokenize{eLCS:module-eLCS.Prediction}}\label{\detokenize{eLCS:elcs-prediction-module}}\index{eLCS.Prediction (module)}\index{Prediction (class in eLCS.Prediction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Prediction.Prediction}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{eLCS.Prediction.}\sphinxbfcode{Prediction}}{\emph{population}}{}
Bases: \sphinxcode{object}

Given a match set, this module uses a voting scheme to select the phenotype prediction.

Set up to handle both discrete and continuous phenotypes.
Also set up to try and handle prediction ties if possible.
\index{getDecision() (eLCS.Prediction.Prediction method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Prediction.Prediction.getDecision}}\pysiglinewithargsret{\sphinxbfcode{getDecision}}{}{}
Returns prediction decision.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{getFitnessSum() (eLCS.Prediction.Prediction method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Prediction.Prediction.getFitnessSum}}\pysiglinewithargsret{\sphinxbfcode{getFitnessSum}}{\emph{population}, \emph{low}, \emph{high}}{}
Get the fitness sum of rules in the rule-set. For continuous phenotype prediction.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{population} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{low} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{high} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{eLCS.Timer module}
\label{\detokenize{eLCS:module-eLCS.Timer}}\label{\detokenize{eLCS:elcs-timer-module}}\index{eLCS.Timer (module)}\index{Timer (class in eLCS.Timer)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Timer.Timer}}\pysigline{\sphinxbfcode{class }\sphinxcode{eLCS.Timer.}\sphinxbfcode{Timer}}
Bases: \sphinxcode{object}

Tracks and stores the run time of algorithm and some of it’s major components
\index{reportTimes() (eLCS.Timer.Timer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Timer.Timer.reportTimes}}\pysiglinewithargsret{\sphinxbfcode{reportTimes}}{}{}
Reports the time summaries for this run.

Returns a string ready to be printed out.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The time summaries for the run

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{returnGlobalTimer() (eLCS.Timer.Timer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Timer.Timer.returnGlobalTimer}}\pysiglinewithargsret{\sphinxbfcode{returnGlobalTimer}}{}{}
Set the global end timer, call at very end of algorithm
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The global time returned in minutes

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{setTimerRestart() (eLCS.Timer.Timer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Timer.Timer.setTimerRestart}}\pysiglinewithargsret{\sphinxbfcode{setTimerRestart}}{\emph{remakeFile}}{}
Sets all time values to the those previously evolved in the loaded popFile
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{remakeFile} (\sphinxstyleliteralemphasis{str}) \textendash{} File path to the remakeFile

\end{description}\end{quote}

\end{fulllineitems}

\index{startTimeDeletion() (eLCS.Timer.Timer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Timer.Timer.startTimeDeletion}}\pysiglinewithargsret{\sphinxbfcode{startTimeDeletion}}{}{}
Tracks Deletion Time

\end{fulllineitems}

\index{startTimeEvaluation() (eLCS.Timer.Timer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Timer.Timer.startTimeEvaluation}}\pysiglinewithargsret{\sphinxbfcode{startTimeEvaluation}}{}{}
Tracks Evaluation Time

\end{fulllineitems}

\index{startTimeMatching() (eLCS.Timer.Timer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Timer.Timer.startTimeMatching}}\pysiglinewithargsret{\sphinxbfcode{startTimeMatching}}{}{}
Tracks MatchSet Time

\end{fulllineitems}

\index{startTimeSelection() (eLCS.Timer.Timer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Timer.Timer.startTimeSelection}}\pysiglinewithargsret{\sphinxbfcode{startTimeSelection}}{}{}
Tracks Selection Time

\end{fulllineitems}

\index{startTimeSubsumption() (eLCS.Timer.Timer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Timer.Timer.startTimeSubsumption}}\pysiglinewithargsret{\sphinxbfcode{startTimeSubsumption}}{}{}
Tracks Subsumption Time

\end{fulllineitems}

\index{stopTimeDeletion() (eLCS.Timer.Timer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Timer.Timer.stopTimeDeletion}}\pysiglinewithargsret{\sphinxbfcode{stopTimeDeletion}}{}{}
Tracks Deletion Time

\end{fulllineitems}

\index{stopTimeEvaluation() (eLCS.Timer.Timer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Timer.Timer.stopTimeEvaluation}}\pysiglinewithargsret{\sphinxbfcode{stopTimeEvaluation}}{}{}
Tracks Evaluation Time

\end{fulllineitems}

\index{stopTimeMatching() (eLCS.Timer.Timer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Timer.Timer.stopTimeMatching}}\pysiglinewithargsret{\sphinxbfcode{stopTimeMatching}}{}{}
Tracks MatchSet Time

\end{fulllineitems}

\index{stopTimeSelection() (eLCS.Timer.Timer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Timer.Timer.stopTimeSelection}}\pysiglinewithargsret{\sphinxbfcode{stopTimeSelection}}{}{}
Tracks Selection Time

\end{fulllineitems}

\index{stopTimeSubsumption() (eLCS.Timer.Timer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eLCS:eLCS.Timer.Timer.stopTimeSubsumption}}\pysiglinewithargsret{\sphinxbfcode{stopTimeSubsumption}}{}{}
Tracks Subsumption Time

\end{fulllineitems}


\end{fulllineitems}



\section{Module contents}
\label{\detokenize{eLCS:module-eLCS}}\label{\detokenize{eLCS:module-contents}}\index{eLCS (module)}

\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{e}
\item {\sphinxstyleindexentry{eLCS}}\sphinxstyleindexpageref{eLCS:\detokenize{module-eLCS}}
\item {\sphinxstyleindexentry{eLCS.Algorithm}}\sphinxstyleindexpageref{eLCS:\detokenize{module-eLCS.Algorithm}}
\item {\sphinxstyleindexentry{eLCS.ClassAccuracy}}\sphinxstyleindexpageref{eLCS:\detokenize{module-eLCS.ClassAccuracy}}
\item {\sphinxstyleindexentry{eLCS.Classifier}}\sphinxstyleindexpageref{eLCS:\detokenize{module-eLCS.Classifier}}
\item {\sphinxstyleindexentry{eLCS.ClassifierSet}}\sphinxstyleindexpageref{eLCS:\detokenize{module-eLCS.ClassifierSet}}
\item {\sphinxstyleindexentry{eLCS.Constants}}\sphinxstyleindexpageref{eLCS:\detokenize{module-eLCS.Constants}}
\item {\sphinxstyleindexentry{eLCS.DataManagement}}\sphinxstyleindexpageref{eLCS:\detokenize{module-eLCS.DataManagement}}
\item {\sphinxstyleindexentry{eLCS.OfflineEnvironment}}\sphinxstyleindexpageref{eLCS:\detokenize{module-eLCS.OfflineEnvironment}}
\item {\sphinxstyleindexentry{eLCS.OutputFileManager}}\sphinxstyleindexpageref{eLCS:\detokenize{module-eLCS.OutputFileManager}}
\item {\sphinxstyleindexentry{eLCS.Prediction}}\sphinxstyleindexpageref{eLCS:\detokenize{module-eLCS.Prediction}}
\item {\sphinxstyleindexentry{eLCS.Timer}}\sphinxstyleindexpageref{eLCS:\detokenize{module-eLCS.Timer}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}